"use strict";(globalThis.webpackChunkgsf_docusaurus_template=globalThis.webpackChunkgsf_docusaurus_template||[]).push([[5158],{6218(e,i,n){n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"catalog/architecture/compress-ml-models-for-inference","title":"Optimize the size of AI/ML models","description":"Large-scale AI/ML models require significant storage space and take more resources to run as compared to optimized models. Modern model optimization techniques can dramatically reduce model size and inference costs while maintaining accuracy.","source":"@site/docs/catalog/architecture/compress-ml-models-for-inference.md","sourceDirName":"catalog/architecture","slug":"/catalog/architecture/compress-ml-models-for-inference","permalink":"/gsf-patterns/catalog/architecture/compress-ml-models-for-inference","draft":false,"unlisted":false,"editUrl":"https://github.com/Green-Software-Foundation/patterns/edit/main/docs/catalog/architecture/compress-ml-models-for-inference.md","tags":[{"inline":true,"label":"ai","permalink":"/gsf-patterns/tags/ai"},{"inline":true,"label":"machine-learning","permalink":"/gsf-patterns/tags/machine-learning"},{"inline":true,"label":"role:data-scientist","permalink":"/gsf-patterns/tags/role-data-scientist"},{"inline":true,"label":"role:software-engineer","permalink":"/gsf-patterns/tags/role-software-engineer"},{"inline":true,"label":"size:medium","permalink":"/gsf-patterns/tags/size-medium"}],"version":"current","frontMatter":{"version":1,"submitted_by":"navveenb","published_date":"2022-11-10T00:00:00.000Z","category":"architecture","description":"Large-scale AI/ML models require significant storage space and take more resources to run as compared to optimized models. Modern model optimization techniques can dramatically reduce model size and inference costs while maintaining accuracy.","tags":["ai","machine-learning","role:data-scientist","role:software-engineer","size:medium"]},"sidebar":"tutorialSidebar","previous":{"title":"Choose the region that is closest to users","permalink":"/gsf-patterns/catalog/architecture/choose-region-closest-to-users"},"next":{"title":"Containerize your workloads","permalink":"/gsf-patterns/catalog/architecture/containerize-your-workload-where-applicable"}}');var s=n(4848),t=n(8453);const l={version:1,submitted_by:"navveenb",published_date:new Date("2022-11-10T00:00:00.000Z"),category:"architecture",description:"Large-scale AI/ML models require significant storage space and take more resources to run as compared to optimized models. Modern model optimization techniques can dramatically reduce model size and inference costs while maintaining accuracy.",tags:["ai","machine-learning","role:data-scientist","role:software-engineer","size:medium"]},a="Optimize the size of AI/ML models",o={},c=[{value:"Description",id:"description",level:2},{value:"Solution",id:"solution",level:2},{value:"1. Quantization (Table Stakes for 2025)",id:"1-quantization-table-stakes-for-2025",level:3},{value:"2. Knowledge Distillation",id:"2-knowledge-distillation",level:3},{value:"3. Pruning",id:"3-pruning",level:3},{value:"4. Architectural Efficiency",id:"4-architectural-efficiency",level:3},{value:"5. Low-Rank Factorization",id:"5-low-rank-factorization",level:3},{value:"SCI Impact",id:"sci-impact",level:2},{value:"Assumptions",id:"assumptions",level:2},{value:"Considerations",id:"considerations",level:2},{value:"References",id:"references",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"optimize-the-size-of-aiml-models",children:"Optimize the size of AI/ML models"})}),"\n",(0,s.jsx)(i.h2,{id:"description",children:"Description"}),"\n",(0,s.jsx)(i.p,{children:"Large-scale AI/ML models require significant storage space and take more resources to run as compared to optimized models. Modern AI models, particularly large language models (LLMs), can range from billions to hundreds of billions of parameters, making deployment challenging. Model optimization techniques can reduce model size by 50-90% while maintaining acceptable accuracy, dramatically lowering storage, memory, and compute requirements."}),"\n",(0,s.jsx)(i.h2,{id:"solution",children:"Solution"}),"\n",(0,s.jsx)(i.p,{children:"Apply modern model optimization strategies to reduce model size and improve inference efficiency. These techniques can be used individually or combined for maximum effect:"}),"\n",(0,s.jsx)(i.h3,{id:"1-quantization-table-stakes-for-2025",children:"1. Quantization (Table Stakes for 2025)"}),"\n",(0,s.jsx)(i.p,{children:"Quantization reduces the numerical precision of model weights and activations, decreasing model size and speeding up inference:"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Post-Training Quantization:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"INT8 quantization"}),": Converts 32-bit floating point to 8-bit integers, reducing model size by ~75%"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"FP16 (Half-precision)"}),": Uses 16-bit floats, reducing size by 50% with minimal accuracy loss"]}),"\n",(0,s.jsx)(i.li,{children:"Easy to apply without retraining, supported by most frameworks"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Quantization-Aware Training (QAT):"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Simulates quantization during training for better accuracy preservation"}),"\n",(0,s.jsx)(i.li,{children:"Results in models that perform well when quantized"}),"\n",(0,s.jsx)(i.li,{children:"More accurate than post-training quantization but requires retraining"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Advanced Quantization for LLMs:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"GPTQ"}),": Optimal quantization specifically designed for large language models"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"AWQ (Activation-aware Weight Quantization)"}),": Preserves important weights for better accuracy"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"GGUF/GGML"}),": Quantization formats optimized for CPU inference (used by llama.cpp)"]}),"\n",(0,s.jsx)(i.li,{children:"Can achieve 3-4 bit quantization with acceptable quality loss"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"2-knowledge-distillation",children:"2. Knowledge Distillation"}),"\n",(0,s.jsx)(i.p,{children:'Train a smaller "student" model to mimic a larger "teacher" model\'s behavior:'}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Process:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Train large teacher model to high accuracy"}),"\n",(0,s.jsx)(i.li,{children:"Use teacher's predictions (soft targets) to train smaller student model"}),"\n",(0,s.jsx)(i.li,{children:"Student learns to approximate teacher's decision boundaries, not just labels"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Student models are typically 10-100x smaller than teachers"}),"\n",(0,s.jsx)(i.li,{children:"Can preserve 95%+ of teacher model accuracy"}),"\n",(0,s.jsx)(i.li,{children:"Enables deployment on resource-constrained devices"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Modern Examples:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"DistilBERT (66M params) distilled from BERT (110M params), 97% accuracy retention"}),"\n",(0,s.jsx)(i.li,{children:"Microsoft Phi-3-mini (3.8B params) achieving performance competitive with much larger models"}),"\n",(0,s.jsx)(i.li,{children:"TinyLLaMA (1.1B params) distilled knowledge from larger LLaMA models"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"3-pruning",children:"3. Pruning"}),"\n",(0,s.jsx)(i.p,{children:"Remove unnecessary weights or structures from trained models:"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Unstructured Pruning:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Remove individual weights with smallest magnitude"}),"\n",(0,s.jsx)(i.li,{children:"Can achieve 80-90% sparsity with minimal accuracy loss"}),"\n",(0,s.jsx)(i.li,{children:"Requires sparse computation kernels for speedup"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Structured Pruning:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Remove entire channels, filters, or attention heads"}),"\n",(0,s.jsx)(i.li,{children:"Directly reduces model dimensions and computation"}),"\n",(0,s.jsx)(i.li,{children:"Works with standard hardware without special kernels"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Dynamic Pruning:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Adaptively remove computations based on input"}),"\n",(0,s.jsx)(i.li,{children:"Early exit mechanisms for simple inputs"}),"\n",(0,s.jsx)(i.li,{children:"Lottery Ticket Hypothesis: find sparse subnetworks that train to similar accuracy"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"4-architectural-efficiency",children:"4. Architectural Efficiency"}),"\n",(0,s.jsx)(i.p,{children:"Choose or design architectures optimized for efficiency:"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Efficient Model Families:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"MobileNets v4"}),": Optimized for mobile and edge devices"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"EfficientNet"}),": Compound scaling for optimal size-accuracy tradeoff"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"SqueezeNet"}),": Achieves AlexNet-level accuracy at 50x smaller size"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Efficient Transformers"}),": Linear attention mechanisms for reduced complexity"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Small but Capable LLMs (2025):"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Microsoft Phi-3"})," (3.8B, 7B, 14B): Small models with strong performance"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Mistral 7B"}),": Efficient 7B parameter model outperforming larger models"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Gemma 2B/7B"})," (Google): Efficient open models for diverse tasks"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"LLaMA 3 variants"}),": Multiple sizes optimized for different deployment scenarios"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"5-low-rank-factorization",children:"5. Low-Rank Factorization"}),"\n",(0,s.jsx)(i.p,{children:"Decompose weight matrices into products of smaller matrices:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"LoRA (Low-Rank Adaptation): Efficient fine-tuning with <1% parameters"}),"\n",(0,s.jsx)(i.li,{children:"QLoRA: Combines quantization with LoRA for ultra-efficient training"}),"\n",(0,s.jsx)(i.li,{children:"Enables fine-tuning large models on consumer GPUs"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"sci-impact",children:"SCI Impact"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"SCI = (E * I) + M per R"}),"\n",(0,s.jsx)(i.a,{href:"https://grnsft.org/sci",children:"Software Carbon Intensity Spec"})]}),"\n",(0,s.jsx)(i.p,{children:"Optimizing AI/ML model size impacts SCI as follows:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"E"}),": Reduces energy consumption for inference through:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Lower memory bandwidth requirements"}),"\n",(0,s.jsx)(i.li,{children:"Fewer computational operations"}),"\n",(0,s.jsx)(i.li,{children:"Reduced storage I/O"}),"\n",(0,s.jsx)(i.li,{children:"Enables running on more energy-efficient hardware"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"M"}),": Reduces embodied carbon by:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Requiring less memory capacity"}),"\n",(0,s.jsx)(i.li,{children:"Enabling deployment on smaller, less powerful devices"}),"\n",(0,s.jsx)(i.li,{children:"Reducing data center infrastructure needs"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"assumptions",children:"Assumptions"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Model optimization is applied with accuracy evaluation to ensure acceptable performance"}),"\n",(0,s.jsx)(i.li,{children:"Target deployment environment is known (cloud, edge, mobile) to guide optimization choices"}),"\n",(0,s.jsx)(i.li,{children:"Optimization tools and frameworks are available for the model type"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"considerations",children:"Considerations"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Accuracy-Size Tradeoff"}),": Always evaluate optimized models against accuracy requirements"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Technique Selection"}),": Different techniques work better for different model types:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"LLMs: GPTQ, AWQ quantization + LoRA fine-tuning"}),"\n",(0,s.jsx)(i.li,{children:"Vision models: Quantization + pruning"}),"\n",(0,s.jsx)(i.li,{children:"Small models for edge: Knowledge distillation + MobileNet architectures"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Hardware Compatibility"}),": Ensure optimization format is supported by target hardware"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Maintenance"}),": Document optimization settings for reproducibility"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Iterative Approach"}),": Start with simple techniques (post-training quantization) before complex methods"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Latency vs. Throughput"}),": Some optimizations improve one at the expense of the other"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://onnxruntime.ai/docs/performance/model-optimizations/",children:"ONNX Runtime - Model Optimization"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://developer.nvidia.com/tensorrt",children:"TensorRT - NVIDIA GPU Inference Optimization"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://github.com/vllm-project/vllm",children:"vLLM - High-Throughput LLM Serving"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/2210.17323",children:"GPTQ - Accurate Quantization for LLMs"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/2306.00978",children:"AWQ - Activation-aware Weight Quantization"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/1503.02531",children:"Knowledge Distillation"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/1803.03635",children:"The Lottery Ticket Hypothesis"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/2106.09685",children:"LoRA - Low-Rank Adaptation"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://grnsft.org/sci",children:"Software Carbon Intensity Spec"})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,i,n){n.d(i,{R:()=>l,x:()=>a});var r=n(6540);const s={},t=r.createContext(s);function l(e){const i=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:i},e.children)}}}]);
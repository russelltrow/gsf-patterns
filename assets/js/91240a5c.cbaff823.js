"use strict";(globalThis.webpackChunkgsf_docusaurus_template=globalThis.webpackChunkgsf_docusaurus_template||[]).push([[4882],{7902(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"catalog/operations/dynamic-scaling-based-on-demand","title":"Dynamic scaling based on demand","description":"Demand for resources depends on user load at any given time. However, most applications run without taking this into consideration, resulting in underused and inefficient resources. Scaling infrastructure dynamically based on actual demand eliminates excess capacity and improves efficiency.","source":"@site/docs/catalog/operations/dynamic-scaling-based-on-demand.md","sourceDirName":"catalog/operations","slug":"/catalog/operations/dynamic-scaling-based-on-demand","permalink":"/gsf-patterns/catalog/operations/dynamic-scaling-based-on-demand","draft":false,"unlisted":false,"editUrl":"https://github.com/Green-Software-Foundation/patterns/edit/main/docs/catalog/operations/dynamic-scaling-based-on-demand.md","tags":[{"inline":true,"label":"compute","permalink":"/gsf-patterns/tags/compute"},{"inline":true,"label":"cloud","permalink":"/gsf-patterns/tags/cloud"},{"inline":true,"label":"serverless","permalink":"/gsf-patterns/tags/serverless"},{"inline":true,"label":"kubernetes","permalink":"/gsf-patterns/tags/kubernetes"},{"inline":true,"label":"role:cloud-engineer","permalink":"/gsf-patterns/tags/role-cloud-engineer"},{"inline":true,"label":"role:software-engineer","permalink":"/gsf-patterns/tags/role-software-engineer"},{"inline":true,"label":"size:medium","permalink":"/gsf-patterns/tags/size-medium"}],"version":"current","frontMatter":{"version":1,"submitted_by":"franziska-nttdata-hesselfeld, yelghali","published_date":"2023-12-14T00:00:00.000Z","category":"operations","description":"Demand for resources depends on user load at any given time. However, most applications run without taking this into consideration, resulting in underused and inefficient resources. Scaling infrastructure dynamically based on actual demand eliminates excess capacity and improves efficiency.","tags":["compute","cloud","serverless","kubernetes","role:cloud-engineer","role:software-engineer","size:medium"]},"sidebar":"tutorialSidebar","previous":{"title":"Operations","permalink":"/gsf-patterns/catalog/operations/"},"next":{"title":"Optimise storage utilization","permalink":"/gsf-patterns/catalog/operations/optimise-storage-resource-utilisation"}}');var a=i(4848),r=i(8453);const t={version:1,submitted_by:"franziska-nttdata-hesselfeld, yelghali",published_date:new Date("2023-12-14T00:00:00.000Z"),category:"operations",description:"Demand for resources depends on user load at any given time. However, most applications run without taking this into consideration, resulting in underused and inefficient resources. Scaling infrastructure dynamically based on actual demand eliminates excess capacity and improves efficiency.",tags:["compute","cloud","serverless","kubernetes","role:cloud-engineer","role:software-engineer","size:medium"]},o="Dynamic scaling based on demand",l={},c=[{value:"Description",id:"description",level:2},{value:"Solution",id:"solution",level:2},{value:"Approach 1: Time-Based Scaling for Predictable Patterns",id:"approach-1-time-based-scaling-for-predictable-patterns",level:3},{value:"Approach 2: Metrics-Driven Scaling for Reactive Demand",id:"approach-2-metrics-driven-scaling-for-reactive-demand",level:3},{value:"Combined Strategy",id:"combined-strategy",level:3},{value:"SCI Impact",id:"sci-impact",level:2},{value:"Assumptions",id:"assumptions",level:2},{value:"Considerations",id:"considerations",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"dynamic-scaling-based-on-demand",children:"Dynamic scaling based on demand"})}),"\n",(0,a.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,a.jsx)(n.p,{children:"Demand for resources depends on user load at any given time. However, most applications run without taking this into consideration, resulting in underused and inefficient resources. By scaling infrastructure dynamically based on actual demand, whether through predictable time patterns or reactive metrics, you can eliminate excess capacity and improve both energy and hardware efficiency."}),"\n",(0,a.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,a.jsx)(n.p,{children:"Implement dynamic scaling using one or both of the following complementary approaches:"}),"\n",(0,a.jsx)(n.h3,{id:"approach-1-time-based-scaling-for-predictable-patterns",children:"Approach 1: Time-Based Scaling for Predictable Patterns"}),"\n",(0,a.jsx)(n.p,{children:"Review workloads for predictable patterns and identify periods of low or no activity where resources can be scaled back:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Inspect CPU load over time to identify underutilized resources"}),"\n",(0,a.jsx)(n.li,{children:"Scale back resources during periods of low utilization (e.g., nights, weekends for business applications)"}),"\n",(0,a.jsx)(n.li,{children:"Consolidate underutilized Virtual Machines"}),"\n",(0,a.jsx)(n.li,{children:"Shut down resources on a schedule when not needed"}),"\n",(0,a.jsx)(n.li,{children:"Remove permanently idle resources"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This approach works best when traffic patterns are predictable and consistent. Scaling based on time is simpler to implement and requires less sophisticated monitoring infrastructure."}),"\n",(0,a.jsx)(n.h3,{id:"approach-2-metrics-driven-scaling-for-reactive-demand",children:"Approach 2: Metrics-Driven Scaling for Reactive Demand"}),"\n",(0,a.jsx)(n.p,{children:"Scale infrastructure based on actual demand metrics that directly correlate with your application's load:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Demand Metrics Examples:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"HTTP request rates"}),"\n",(0,a.jsx)(n.li,{children:"Message queue length"}),"\n",(0,a.jsx)(n.li,{children:"Database connection pools"}),"\n",(0,a.jsx)(n.li,{children:"Custom business metrics (e.g., active user sessions)"}),"\n",(0,a.jsx)(n.li,{children:"Cloud alerting events"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Implement custom scalers tailored to your application's demand drivers"}),"\n",(0,a.jsx)(n.li,{children:"Use platform-specific tools (e.g., AWS Auto Scaling, Azure Auto Scale, GCP Autoscaler)"}),"\n",(0,a.jsxs)(n.li,{children:["For Kubernetes: Use ",(0,a.jsx)(n.a,{href:"https://keda.sh",children:"KEDA (Kubernetes Event-Driven Autoscaling)"})," to build event-driven applications"]}),"\n",(0,a.jsx)(n.li,{children:"Enable scaling down to zero when there is no demand (supported by KEDA and serverless platforms)"}),"\n",(0,a.jsx)(n.li,{children:"Implement cluster auto-scaling and bursting capabilities to scale infrastructure based on pod demand"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Why metrics-driven scaling?"})," By default, platforms like Kubernetes scale based on CPU and RAM utilization. However, it's often difficult to correlate your application's actual demand drivers with CPU and RAM utilization. Scaling on relevant metrics provides more precise resource allocation."]}),"\n",(0,a.jsx)(n.h3,{id:"combined-strategy",children:"Combined Strategy"}),"\n",(0,a.jsx)(n.p,{children:"For optimal efficiency, use both approaches:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Time-based scaling for known low-traffic periods"}),"\n",(0,a.jsx)(n.li,{children:"Metrics-driven scaling for handling variable demand during active hours"}),"\n",(0,a.jsx)(n.li,{children:"This combination ensures resources are right-sized at all times"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"sci-impact",children:"SCI Impact"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"SCI = (E * I) + M per R"}),"\n",(0,a.jsx)(n.a,{href:"https://grnsft.org/sci",children:"Software Carbon Intensity Spec"})]}),"\n",(0,a.jsx)(n.p,{children:"Dynamic scaling based on demand impacts SCI as follows:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"E"}),": Reduces electricity consumed by running only the resources needed for current demand"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"M"}),": Reduces embodied carbon emissions by decreasing the total amount of hardware required to support the workload"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"assumptions",children:"Assumptions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"For time-based scaling: Traffic patterns are predictable and consistent enough to define a schedule"}),"\n",(0,a.jsx)(n.li,{children:"For metrics-driven scaling: The metrics that drive application demand and scaling needs are known and measurable"}),"\n",(0,a.jsx)(n.li,{children:"The application architecture supports scaling (stateless or with proper state management)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"considerations",children:"Considerations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Consider starting with the easiest optimizations first (time-based scaling is simpler to implement)"}),"\n",(0,a.jsx)(n.li,{children:"If workloads have predictable usage patterns, time-based scaling may be sufficient and simpler than metrics-driven approaches"}),"\n",(0,a.jsx)(n.li,{children:"Metrics-driven scaling requires more sophisticated monitoring and configuration but provides better responsiveness to demand changes"}),"\n",(0,a.jsx)(n.li,{children:"Account for scaling delays (cold starts) when sizing minimum capacity"}),"\n",(0,a.jsx)(n.li,{children:"Test scaling behavior under various load conditions to ensure performance requirements are met"}),"\n",(0,a.jsx)(n.li,{children:"For Kubernetes: Combine horizontal pod autoscaling (HPA/KEDA) with cluster autoscaling for complete infrastructure optimization"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://docs.aws.amazon.com/wellarchitected/latest/sustainability-pillar/sus_sus_user_a2.html",children:"AWS Sustainability Pillar"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://keda.sh",children:"KEDA - Kubernetes Event-Driven Autoscaling"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://grnsft.org/sci",children:"Software Carbon Intensity Spec"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>t,x:()=>o});var s=i(6540);const a={},r=s.createContext(a);function t(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);